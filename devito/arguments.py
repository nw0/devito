import abc

import numpy as np
from sympy import Symbol
from cached_property import cached_property
from collections import defaultdict, namedtuple
from functools import reduce

from devito.exceptions import InvalidArgument
from devito.logger import debug
from devito.visitors import Visitor
from devito.tools import filter_ordered, flatten
from devito.function import CompositeFunction, SymbolicFunction

""" This module provides a set of classes that help in processing runtime arguments for
    kernels generated by devito. There are two class hierarchies here:
    - ArgumentProvider: These are for objects that might be used in the expression
      provided to the operator as symbols but might resolve to runtime arguments after
      code generation. Each ArgumentProvider provides one (or more) Argument
      object(s).
    - Argument: Classes inheriting from this are for objects that represent the
      argument itself. Each ArgumentProvider might provide one or more such objects
      which are used as placeholders for the argument as well as for verification and
      derivation of default values.
"""


class Argument(object):

    """ Abstract base class for any object that represents a run time argument for
        generated kernels.
    """

    __metaclass__ = abc.ABCMeta

    is_ScalarArgument = False
    is_TensorArgument = False
    is_PtrArgument = False

    def __init__(self, name, dependencies):
        self.name = name
        self.dependencies = dependencies

    @property
    def gets_value_from(self):
        return [x for x in self.dependencies if x.dependency_type=="gets_value_from"]

    @property
    def verified_by(self):
        return [x for x in self.dependencies if x.dependency_type=="verified_by"]

    def __repr__(self):
        return self.name


class ScalarArgument(Argument):

    """ Class representing scalar arguments that a kernel might expect.
        Most commonly used to pass dimension sizes
        enforce determines whether any reduction will be performed or not.
        i.e. if it is a user-provided value, use it directly.
    """

    is_ScalarArgument = True

    def __init__(self, name, dependencies):
        super(ScalarArgument, self).__init__(name, dependencies)
        self.dtype = np.int32

    def verify(self, value, engine, enforce=False):
        # Assuming self._value was initialised as appropriate for the reducer
        if value is not None:
            if self._value is not None and not enforce:
                self._value = self.reducer(self._value, value)
            else:
                self._value = value
        return self._value is not None


class TensorArgument(Argument):

    """ Class representing tensor arguments that a kernel might expect.
        Most commonly used to pass numpy-like multi-dimensional arrays.
    """

    is_TensorArgument = True

    def __init__(self, provider, dependencies=[]):
        super(TensorArgument, self).__init__(provider.name, dependencies + [Dependency("gets_value_from", provider)])
        self.dtype = provider.dtype
        self.provider = provider

    def verify(self, value, engine):
        if value is None:
            value = self._value

        verify = len(self.provider.shape) == len(value.shape)

        verify = verify and all(d.verify(v, engine) for d, v in
                                zip(self.provider.indices, value.shape))
        if verify:
            self._value = value

        return self._value is not None and verify


class PtrArgument(Argument):

    """ Class representing arbitrary arguments that a kernel might expect.
        These are passed as void pointers and then promptly casted to their
        actual type.
    """

    is_PtrArgument = True

    def __init__(self, provider):
        super(PtrArgument, self).__init__(provider.name, [Dependency("gets_value_from", provider)])
        self.dtype = provider.dtype


class DimensionArgProvider(object):

    """ This class is used to decorate the Dimension class with behaviour required
        to handle runtime arguments. All properties/methods defined here are available
        in any Dimension object.
    """

    # TODO: Can we do without a verify on a dimension?
    def verify(self, value, enforce=False):
        verify = True
        if value is None:
            if self.value is not None:
                return True

            try:
                parent_value = self.parent.value
                if parent_value is None:
                    return False
            except AttributeError:
                return False
        # Make sure we're dealing with a 3-tuple. See docstring of _promote for more
        value = self._promote(value, engine)
        if hasattr(self, 'parent'):
            parent_value = self.parent.value
            if parent_value is not None and not enforce:
                parent_value = self._promote(parent_value, engine)
                value = tuple([self.reducer(i1, i2) for i1, i2 in zip(value,
                                                                      parent_value)])
            verify = verify and self.parent.verify(value, engine)

        if value == self.value:
            return True

        # Derived dimensions could be linked through constraints
        # At this point, a constraint needs to be added that enforces
        # dim_e - dim_s < SOME_MAX
        # Also need a default constraint that dim_e > dim_s (or vice-versa)
        verify = verify and all([a.verify(v, engine, enforce=enforce) for a, v in
                                 zip(self.rtargs, value)])
        return verify
        


class ArgumentEngine(object):
    def __init__(self, stencils, parameters):
        self.stencils = stencils
        self.parameters = parameters
        self.argument_mapper = self._build_argument_mapper(parameters)
        self.arguments = [x for x in self.argument_mapper if isinstance(x, Argument)]

    def handle(self, **kwargs):
        kwargs = self._extract_children_of_composites(kwargs)

        values = self._derive_values(kwargs)

        assert(self._verify(values))

        return dict([(k.name, v) for k, v in values.items()])
        

    def _build_argument_mapper(self, parameters):
        # Pass through SymbolicFunction
        symbolic_functions = [x for x in parameters if isinstance(x, SymbolicFunction)]
        dimension_dependency_mapper = dict()
        tensor_arguments = []
        for f in symbolic_functions:
            argument = ArgumentVisitor().visit(f)
            tensor_arguments.append(argument)
            for i, d in enumerate(f.indices):
                if d not in dimension_dependency_mapper:
                    dimension_dependency_mapper[d] = []
                dimension_dependency_mapper[d].append(Dependency("gets_value_from", argument, param=i))
        # Record dependencies in Dimensions
        dimension_parameters = []
        for dim, deps in dimension_dependency_mapper.items():
            dimension_parameters.append(DimensionParameter(dim, deps))

        # Pass Dimensions
        scalar_arguments = []
        for dimension_parameter in dimension_parameters:
            scalar_arguments += ArgumentVisitor().visit(dimension_parameter)

        other_arguments = [ArgumentVisitor().visit(x) for x in parameters if x not in tensor_arguments + scalar_arguments]
            
        return tensor_arguments + dimension_parameters + scalar_arguments + other_arguments

    def _extract_children_of_composites(self, kwargs):
        new_params = {}
        # If we've been passed CompositeFunction objects as kwargs,
        # they might have children that need to be substituted as well.
        for k, v in kwargs.items():
            if isinstance(v, CompositeFunction):
                orig_param_l = [i for i in self.parameters if i.name == k]
                # If I have been passed a parameter, I must have seen it before
                if len(orig_param_l) == 0:
                    raise InvalidArgument("Parameter %s does not exist in expressions " +
                                          "passed to this Operator" % k)
                # We've made sure the list isn't empty. Names should be unique so it
                # should have exactly one entry
                assert(len(orig_param_l) == 1)
                orig_param = orig_param_l[0]
                # Pull out the children and add them to kwargs
                for orig_child, new_child in zip(orig_param.children, v.children):
                    new_params[orig_child.name] = new_child
        kwargs.update(new_params)
        return kwargs

    def _derive_values(self, kwargs):
        # Use kwargs
        values = {}
        for i in self.arguments:
            values[i] = get_value(i, kwargs.pop(i.name, None), values)

        # Make sure we've used all arguments passed
        if len(kwargs) > 0:
            raise InvalidArgument("Unknown arguments passed: " + ", ".join(kwargs.keys()))

        # Derive values for other arguments
        for i in self.arguments:
            if values[i] is None:
                provided_values = [get_value(i, x, values) for x in i.gets_value_from]
                assert(len(provided_values) > 0)
                if len(provided_values) == 1:
                    values[i] = provided_values[0]
                else:
                    values[i] = reduce(provided_values)
        return values

    def _verify(self, values):
        verify = True
        for i in values:
            verify = verify and all(verify(i, x) for x in i.verified_by)
        return verify        

    def extract_dimension_offsets(self, stencils):
        all_dimension_offsets = defaultdict(list)
        dimension_offsets = defaultdict(lambda: (0, 0))

        for s in stencils:
            for d in s:
                all_dimension_offsets[d] += s[d]

        for d in all_dimension_offsets:
            dimension_offsets[d] = (-min(all_dimension_offsets[d]),
                                    max(all_dimension_offsets[d]))
            try:
                # TODO: Maybe there should be some sort of reduction here
                dimension_offsets[d.parent] = dimension_offsets[d]
            except:
                pass
        self.dimension_offsets = dimension_offsets

        
class ArgumentVisitor(Visitor):
    """ Visits types to return their runtime arguments
    """
    def visit_SymbolicFunction(self, o):
        return TensorArgument(o)
    
    def visit_DimensionParameter(self, o):
        dependency = Dependency("gets_value_from", o)
        size = ScalarArgument(o.provider.size_name, [dependency])
        start = ScalarArgument(o.provider.start_name, [dependency])
        end = ScalarArgument(o.provider.end_name, [dependency])
        return [size, start, end]
    
    def visit_Object(self, o):
        return PtrArgument(o)

    def visit_Array(self, o):
        return TensorArgument(o)

    def visit_Scalar(self, o):
        dependency = Dependency("gets_value_from", o)
        return ScalarArgument(o.name, o)

    def visit_ConstantFunction(self, o):
        # TODO: Add option for delayed query of default value
        return [ScalarArgument(o.name, o, default_value=o.data)]

    
class ValueVisitor(Visitor):
    """Visits types to derive their value
    """
    def __init__(self, consumer, known_values):
        self.consumer = consumer
        self.known_values = known_values
        super(ValueVisitor, self).__init__()
        
    def visit_SymbolicFunction(self, o, param=None):
        assert(isinstance(self.consumer, TensorArgument))
        return o.data

    def visit_Dependency(self, o):
        return self.visit(o.obj, o.param)

    def visit_object(self, o, param=None):
        return o

    def visit_DimensionParameter(self, o, param=None):
        # We are being asked to provide a default value for dim_start
        if self.consumer.name == o.provider.start_name:
            return 0
        
        provided_values = [get_value(o, x, self.known_values) for x in o.gets_value_from]
        value = reduce(max, provided_values)
        return reduce(max, provided_values)

    def visit_TensorArgument(self, o, param):
        assert(isinstance(self.consumer, DimensionParameter))
        return self.known_values[o].shape[param]

    
def get_value(consumer, provider, values):
    return ValueVisitor(consumer, values).visit(provider)

    
class Dependency(object):
    _types = ["gets_value_from", "verified_by"]
    def __init__(self, dependency_type, obj, param=None):
        assert(dependency_type in self._types)
        self.dependency_type = dependency_type
        self.obj = obj
        self.param = param

    def __repr__(self):
        return "(" + self.dependency_type + ":" + str(self.obj) + ")"

class DimensionParameter(object):
    def __init__(self, provider, dependencies):
        self.provider = provider
        self.dependencies = dependencies

    @property
    def gets_value_from(self):
        return [x for x in self.dependencies if x.dependency_type=="gets_value_from"]

    @property
    def verified_by(self):
        return [x for x in self.dependencies if x.dependency_type=="verified_by"]


def runtime_arguments(parameters):
    return flatten([ArgumentVisitor().visit(p) for p in parameters])


def log_args(arguments):
    arg_str = []
    for k, v in arguments.items():
        if hasattr(v, 'shape'):
            arg_str.append('(%s, shape=%s, L2 Norm=%d)' %
                           (k, str(v.shape), np.linalg.norm(v.view())))
        else:
            arg_str.append('(%s, value=%s)' % (k, str(v)))
    debug("Passing Arguments: " + ", ".join(arg_str))
